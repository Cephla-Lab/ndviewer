#!/usr/bin/env python3
"""
Test script for visualizing downsampler output using matplotlib.
This test creates visualizations of the downsampled mosaics generated by the downsampler module.

Usage:
    python test_downsampler_visualization.py [acquisition_directory_path]
    
If no path is provided, the script will create synthetic test data.
"""

import os
import sys
import time
import tempfile
import argparse
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from pathlib import Path
from typing import Dict, List, Tuple, Optional

# Add the parent directory to the path to import our modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def create_test_data_structure(base_dir: Path) -> bool:
    """Create a minimal test data structure for testing the downsampler"""
    try:
        # Create test directory structure
        test_dir = base_dir / "test_acquisition" / "0"
        test_dir.mkdir(parents=True, exist_ok=True)
        
        # Create coordinates.csv
        coordinates_data = [
            "fov,x (mm),y (mm),region",
            "1,0.0,0.0,region1",
            "2,1.0,0.0,region1", 
            "3,0.0,1.0,region1",
            "4,1.0,1.0,region1",
            "5,2.0,0.0,region2",
            "6,2.0,1.0,region2"
        ]
        
        coord_file = test_dir / "coordinates.csv"
        with open(coord_file, 'w') as f:
            f.write('\n'.join(coordinates_data))
        
        # Create test TIFF files
        for fov in range(1, 7):
            for z in range(3):  # 3 z-layers
                for channel in ['DAPI', 'GFP', 'RFP']:
                    # Create a simple test image
                    img = np.random.randint(0, 65535, (512, 512), dtype=np.uint16)
                    
                    # Add some structure to make it more interesting
                    center_y, center_x = 256, 256
                    y, x = np.ogrid[:512, :512]
                    mask = (x - center_x)**2 + (y - center_y)**2 <= 100**2
                    img[mask] = np.random.randint(30000, 65535, mask.sum(), dtype=np.uint16)
                    
                    # Create filename
                    region = "region1" if fov <= 4 else "region2"
                    filename = f"{region}_{fov:03d}_{z:03d}_fluorescence_{channel}_test.tiff"
                    filepath = test_dir / filename
                    
                    # Save as TIFF
                    import tifffile as tf
                    tf.imwrite(filepath, img)
        
        print(f"✓ Created test data structure in {test_dir}")
        return True
        
    except Exception as e:
        print(f"❌ Failed to create test data: {e}")
        return False

def visualize_single_channel_mosaic(mosaic: np.ndarray, metadata: Dict, title: str = "Single Channel Mosaic"):
    """Visualize a single channel mosaic"""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Main mosaic visualization
    im1 = ax1.imshow(mosaic, cmap='gray', interpolation='nearest')
    ax1.set_title(f"{title}\nShape: {mosaic.shape}")
    ax1.set_xlabel("X (pixels)")
    ax1.set_ylabel("Y (pixels)")
    
    # Add colorbar
    plt.colorbar(im1, ax=ax1, label="Intensity")
    
    # Add grid overlay to show tile boundaries
    tile_size = metadata.get('tile_size', 75)
    grid_dims = metadata.get('grid_dims', (0, 0))
    n_rows, n_cols = grid_dims
    
    # Draw grid lines
    for i in range(n_rows + 1):
        ax1.axhline(y=i * tile_size, color='red', alpha=0.3, linewidth=0.5)
    for j in range(n_cols + 1):
        ax1.axvline(x=j * tile_size, color='red', alpha=0.3, linewidth=0.5)
    
    # Add FOV numbers
    fov_grid = metadata.get('fov_grid', {})
    for (row, col), fov in fov_grid.items():
        x_center = col * tile_size + tile_size // 2
        y_center = row * tile_size + tile_size // 2
        ax1.text(x_center, y_center, str(fov), 
                color='red', fontsize=8, ha='center', va='center',
                bbox=dict(boxstyle="round,pad=0.2", facecolor='white', alpha=0.7))
    
    # Metadata visualization
    ax2.axis('off')
    metadata_text = f"""Mosaic Metadata:
    
Grid Dimensions: {grid_dims}
Tile Size: {tile_size} pixels
Total FOVs: {len(metadata.get('coordinates', {}))}
Regions: {list(set(metadata.get('regions', {}).values()))}
Channels: {metadata.get('channels', [])}

Grid Bounds: {metadata.get('grid_bounds', 'N/A')}
Pixel Scale: {metadata.get('pixel_to_mm_scale', 'N/A')} mm/pixel

Data Type: {mosaic.dtype}
Min Value: {mosaic.min()}
Max Value: {mosaic.max()}
Mean Value: {mosaic.mean():.1f}"""
    
    ax2.text(0.05, 0.95, metadata_text, transform=ax2.transAxes, 
             fontsize=10, verticalalignment='top', fontfamily='monospace',
             bbox=dict(boxstyle="round,pad=0.5", facecolor='lightgray', alpha=0.8))
    
    plt.tight_layout()
    return fig

def visualize_multi_channel_mosaics(channel_mosaics: Dict[str, np.ndarray], 
                                   metadata: Dict, title: str = "Multi-Channel Mosaics"):
    """Visualize multi-channel mosaics"""
    n_channels = len(channel_mosaics)
    if n_channels == 0:
        print("❌ No channel mosaics to visualize")
        return None
    
    # Determine subplot layout
    if n_channels <= 3:
        n_cols = n_channels
        n_rows = 1
    elif n_channels <= 6:
        n_cols = 3
        n_rows = 2
    else:
        n_cols = 4
        n_rows = (n_channels + 3) // 4
    
    fig = plt.figure(figsize=(5 * n_cols, 4 * n_rows + 2))
    
    # Create subplots for each channel
    axes = []
    for i, (channel_name, mosaic) in enumerate(channel_mosaics.items()):
        ax = plt.subplot(n_rows, n_cols, i + 1)
        axes.append(ax)
        
        # Display mosaic
        im = ax.imshow(mosaic, cmap='gray', interpolation='nearest')
        ax.set_title(f"{channel_name}\n{mosaic.shape}")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        
        # Add grid overlay
        tile_size = metadata.get('tile_size', 75)
        grid_dims = metadata.get('grid_dims', (0, 0))
        n_rows_grid, n_cols_grid = grid_dims
        
        # Draw grid lines
        for row in range(n_rows_grid + 1):
            ax.axhline(y=row * tile_size, color='red', alpha=0.3, linewidth=0.5)
        for col in range(n_cols_grid + 1):
            ax.axvline(x=col * tile_size, color='red', alpha=0.3, linewidth=0.5)
        
        # Add FOV numbers (smaller font for multi-channel view)
        fov_grid = metadata.get('fov_grid', {})
        for (row, col), fov in fov_grid.items():
            x_center = col * tile_size + tile_size // 2
            y_center = row * tile_size + tile_size // 2
            ax.text(x_center, y_center, str(fov), 
                    color='red', fontsize=6, ha='center', va='center',
                    bbox=dict(boxstyle="round,pad=0.1", facecolor='white', alpha=0.7))
    
    # Add metadata text
    metadata_ax = plt.subplot(n_rows, n_cols, n_rows * n_cols)
    metadata_ax.axis('off')
    
    metadata_text = f"""Multi-Channel Mosaic Metadata:

Channels: {list(channel_mosaics.keys())}
Grid Dimensions: {metadata.get('grid_dims', 'N/A')}
Tile Size: {metadata.get('tile_size', 'N/A')} pixels
Total FOVs: {len(metadata.get('coordinates', {}))}
Regions: {list(set(metadata.get('regions', {}).values()))}

Data Types: {[mosaic.dtype for mosaic in channel_mosaics.values()]}
Value Ranges: {[(mosaic.min(), mosaic.max()) for mosaic in channel_mosaics.values()]}"""
    
    metadata_ax.text(0.05, 0.95, metadata_text, transform=metadata_ax.transAxes, 
                     fontsize=9, verticalalignment='top', fontfamily='monospace',
                     bbox=dict(boxstyle="round,pad=0.5", facecolor='lightgray', alpha=0.8))
    
    plt.suptitle(title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    return fig

def visualize_coordinate_mapping(metadata: Dict, title: str = "Coordinate Mapping"):
    """Visualize the coordinate mapping and grid structure"""
    coordinates = metadata.get('coordinates', {})
    regions = metadata.get('regions', {})
    grid_bounds = metadata.get('grid_bounds')
    
    if not coordinates:
        print("❌ No coordinates to visualize")
        return None
    
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))
    
    # Physical coordinates plot
    x_coords = [coord[0] for coord in coordinates.values()]
    y_coords = [coord[1] for coord in coordinates.values()]
    fov_numbers = list(coordinates.keys())
    
    # Color by region
    unique_regions = list(set(regions.values()))
    colors = plt.cm.Set3(np.linspace(0, 1, len(unique_regions)))
    region_colors = {region: colors[i] for i, region in enumerate(unique_regions)}
    
    for fov, (x, y) in coordinates.items():
        region = regions.get(fov, 'unknown')
        color = region_colors.get(region, 'gray')
        ax1.scatter(x, y, c=[color], s=100, alpha=0.7)
        ax1.annotate(f'FOV{fov}', (x, y), xytext=(5, 5), 
                    textcoords='offset points', fontsize=8)
    
    ax1.set_xlabel("X (mm)")
    ax1.set_ylabel("Y (mm)")
    ax1.set_title("Physical Coordinates")
    ax1.grid(True, alpha=0.3)
    
    # Add legend
    legend_elements = [plt.Line2D([0], [0], marker='o', color='w', 
                                 markerfacecolor=color, markersize=10, label=region)
                      for region, color in region_colors.items()]
    ax1.legend(handles=legend_elements, loc='upper right')
    
    # Grid structure plot
    fov_grid = metadata.get('fov_grid', {})
    grid_dims = metadata.get('grid_dims', (0, 0))
    n_rows, n_cols = grid_dims
    
    if fov_grid:
        # Create grid visualization
        for (row, col), fov in fov_grid.items():
            region = regions.get(fov, 'unknown')
            color = region_colors.get(region, 'gray')
            
            # Draw rectangle for each tile
            rect = patches.Rectangle((col, row), 1, 1, 
                                   linewidth=1, edgecolor='black', 
                                   facecolor=color, alpha=0.7)
            ax2.add_patch(rect)
            
            # Add FOV number
            ax2.text(col + 0.5, row + 0.5, str(fov), 
                    ha='center', va='center', fontsize=10, fontweight='bold')
    
    ax2.set_xlim(-0.5, n_cols - 0.5)
    ax2.set_ylim(-0.5, n_rows - 0.5)
    ax2.set_xlabel("Grid Column")
    ax2.set_ylabel("Grid Row")
    ax2.set_title("Grid Structure")
    ax2.grid(True, alpha=0.3)
    ax2.set_aspect('equal')
    
    plt.suptitle(title, fontsize=14, fontweight='bold')
    plt.tight_layout()
    return fig

def test_downsampler_visualization():
    """Main test function for downsampler visualization"""
    print("="*80)
    print("DOWNSAMPLER VISUALIZATION TEST")
    print("="*80)
    
    # Create temporary directory for test data
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        
        # Create test data
        print("\n--- Creating Test Data ---")
        if not create_test_data_structure(temp_path):
            print("❌ Failed to create test data structure")
            return False
        
        test_acquisition_dir = temp_path / "test_acquisition"
        
        try:
            # Import downsampler module
            from utils.downsampler import (
                DownsampledNavigator, 
                create_navigation_mosaic,
                create_channel_navigation_mosaics
            )
            print("✓ Successfully imported downsampler module")
            
            # Test 1: Single channel mosaic
            print("\n--- Test 1: Single Channel Mosaic ---")
            navigator = DownsampledNavigator(
                acquisition_dir=test_acquisition_dir,
                tile_size=75,
                cache_enabled=False,  # Disable cache for testing
                n_workers=2  # Use fewer workers for testing
            )
            
            mosaic, metadata = navigator.create_mosaic(timepoint=0)
            print(f"✓ Created single channel mosaic: {mosaic.shape}")
            
            # Visualize single channel mosaic
            fig1 = visualize_single_channel_mosaic(mosaic, metadata, "Single Channel Mosaic")
            fig1.savefig(temp_path / "single_channel_mosaic.png", dpi=150, bbox_inches='tight')
            print(f"✓ Saved single channel visualization: {temp_path / 'single_channel_mosaic.png'}")
            
            # Test 2: Multi-channel mosaics for a region
            print("\n--- Test 2: Multi-Channel Mosaics ---")
            region_name = "region1"  # Use the first region
            
            channel_mosaics, region_metadata = navigator.create_channel_mosaics_for_region(
                region_name=region_name, 
                timepoint=0
            )
            print(f"✓ Created multi-channel mosaics for region '{region_name}': {list(channel_mosaics.keys())}")
            
            # Visualize multi-channel mosaics
            fig2 = visualize_multi_channel_mosaics(channel_mosaics, region_metadata, 
                                                  f"Multi-Channel Mosaics - {region_name}")
            fig2.savefig(temp_path / "multi_channel_mosaics.png", dpi=150, bbox_inches='tight')
            print(f"✓ Saved multi-channel visualization: {temp_path / 'multi_channel_mosaics.png'}")
            
            # Test 3: Coordinate mapping visualization
            print("\n--- Test 3: Coordinate Mapping ---")
            fig3 = visualize_coordinate_mapping(metadata, "Coordinate Mapping Visualization")
            fig3.savefig(temp_path / "coordinate_mapping.png", dpi=150, bbox_inches='tight')
            print(f"✓ Saved coordinate mapping visualization: {temp_path / 'coordinate_mapping.png'}")
            
            # Test 4: Test convenience functions
            print("\n--- Test 4: Convenience Functions ---")
            
            # Test create_navigation_mosaic
            mosaic2, metadata2 = create_navigation_mosaic(
                acquisition_dir=test_acquisition_dir,
                timepoint=0,
                tile_size=50,  # Different tile size
                cache_enabled=False
            )
            print(f"✓ Convenience function mosaic: {mosaic2.shape}")
            
            # Test create_channel_navigation_mosaics
            channel_mosaics2, metadata3 = create_channel_navigation_mosaics(
                acquisition_dir=test_acquisition_dir,
                region_name="region2",  # Different region
                timepoint=0,
                tile_size=50,
                cache_enabled=False
            )
            print(f"✓ Convenience function multi-channel: {list(channel_mosaics2.keys())}")
            
            # Test 5: Coordinate conversion functions
            print("\n--- Test 5: Coordinate Conversion ---")
            
            # Test pixel to mm conversion
            pixel_x, pixel_y = 100, 200
            mm_x, mm_y = navigator.pixel_to_mm(pixel_x, pixel_y)
            print(f"✓ Pixel ({pixel_x}, {pixel_y}) -> MM ({mm_x:.3f}, {mm_y:.3f})")
            
            # Test mm to pixel conversion
            pixel_x2, pixel_y2 = navigator.mm_to_pixel(mm_x, mm_y)
            print(f"✓ MM ({mm_x:.3f}, {mm_y:.3f}) -> Pixel ({pixel_x2}, {pixel_y2})")
            
            # Verify conversion accuracy
            if abs(pixel_x - pixel_x2) <= 1 and abs(pixel_y - pixel_y2) <= 1:
                print("✓ Coordinate conversion accuracy verified")
            else:
                print("⚠️ Coordinate conversion accuracy check failed")
            
            # Display all figures
            plt.show()
            
            print("\n" + "="*80)
            print("✅ ALL TESTS PASSED!")
            print("="*80)
            print(f"Generated visualizations saved in: {temp_path}")
            print("Files created:")
            print(f"  - single_channel_mosaic.png")
            print(f"  - multi_channel_mosaics.png") 
            print(f"  - coordinate_mapping.png")
            
            return True
            
        except Exception as e:
            print(f"❌ Test failed with error: {e}")
            import traceback
            traceback.print_exc()
            return False

def test_with_real_data(acquisition_dir: Path):
    """Test with real data from the provided acquisition directory"""
    print("\n" + "="*80)
    print(f"REAL DATA TEST: {acquisition_dir}")
    print("="*80)
    
    if not acquisition_dir.exists():
        print(f"❌ Acquisition directory does not exist: {acquisition_dir}")
        return False
    
    try:
        from utils.downsampler import DownsampledNavigator
        
        print(f"✓ Using acquisition directory: {acquisition_dir}")
        
        navigator = DownsampledNavigator(
            acquisition_dir=acquisition_dir,
            tile_size=100,
            cache_enabled=True,
            n_workers=4
        )
        
        # Create mosaic
        mosaic, metadata = navigator.create_mosaic(timepoint=0)
        print(f"✓ Real data mosaic created: {mosaic.shape}")
        
        # Visualize single channel mosaic
        fig1 = visualize_single_channel_mosaic(mosaic, metadata, f"Real Data Mosaic - {acquisition_dir.name}")
        output_file = f"real_data_mosaic_{acquisition_dir.name}_{time.time():.0f}.png"
        fig1.savefig(output_file, dpi=150, bbox_inches='tight')
        print(f"✓ Real data visualization saved: {output_file}")
        
        # Try to create multi-channel mosaics if multiple regions exist
        regions = metadata.get('regions', {})
        unique_regions = list(set(regions.values()))
        
        if unique_regions:
            print(f"✓ Found regions: {unique_regions}")
            for region in unique_regions[:2]:  # Limit to first 2 regions
                try:
                    channel_mosaics, region_metadata = navigator.create_channel_mosaics_for_region(
                        region_name=region, 
                        timepoint=0
                    )
                    print(f"✓ Created multi-channel mosaics for region '{region}': {list(channel_mosaics.keys())}")
                    
                    fig2 = visualize_multi_channel_mosaics(channel_mosaics, region_metadata, 
                                                          f"Multi-Channel Mosaics - {region}")
                    output_file2 = f"real_data_multi_channel_{region}_{time.time():.0f}.png"
                    fig2.savefig(output_file2, dpi=150, bbox_inches='tight')
                    print(f"✓ Multi-channel visualization saved: {output_file2}")
                    
                except Exception as e:
                    print(f"⚠️ Failed to create multi-channel mosaics for region '{region}': {e}")
        
        # Coordinate mapping visualization
        fig3 = visualize_coordinate_mapping(metadata, f"Coordinate Mapping - {acquisition_dir.name}")
        output_file3 = f"real_data_coordinates_{acquisition_dir.name}_{time.time():.0f}.png"
        fig3.savefig(output_file3, dpi=150, bbox_inches='tight')
        print(f"✓ Coordinate mapping visualization saved: {output_file3}")
        
        plt.show()
        return True
        
    except Exception as e:
        print(f"❌ Real data test failed: {e}")
        import traceback
        traceback.print_exc()
        return False

if __name__ == "__main__":
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description="Test script for visualizing downsampler output",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python test_downsampler_visualization.py
  python test_downsampler_visualization.py /path/to/acquisition/directory
  python test_downsampler_visualization.py "/path/with spaces/acquisition"
        """
    )
    parser.add_argument(
        'acquisition_dir', 
        nargs='?', 
        type=str,
        help='Path to acquisition directory to test with real data'
    )
    
    args = parser.parse_args()
    
    if args.acquisition_dir:
        # Test with provided real data
        acquisition_path = Path(args.acquisition_dir)
        print(f"Testing with real data from: {acquisition_path}")
        success = test_with_real_data(acquisition_path)
    else:
        # Run the synthetic test
        print("No acquisition directory provided, running with synthetic test data")
        success = test_downsampler_visualization()
    
    if success:
        print("\n✅ Test completed successfully!")
    else:
        print("\n❌ Test failed!")
        sys.exit(1) 